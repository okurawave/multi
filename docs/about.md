承知いたしました。これまでの議論の集大成として、自律型AI開発プラットフォーム `ParallelXec-Agent` の最終設計図を、詳細に記述します。

---

### **【最終設計図】 自律型AI開発プラットフォーム `ParallelXec-Agent`**

#### 1. 総合コンセプト

**「Gitネイティブな自律型AI開発チームによる、品質保証プロセスを内包したソフトウェア自動生成システム」**

ユーザーが自然言語で定義した要件に基づき、統括AIがプロジェクトを計画・管理し、複数の専門AIワーカー（開発、QA）がGitのフィーチャーブランチモデルに則って独立した環境で作業を行う。全プロセスはtmux上で可視化され、レビューとテストを経て、信頼性の高い成果物を自動で生成する。

#### 2. システムアーキテクチャ

*   **コアエンジン (Orchestrator):**
    *   **役割:** システム全体の司令塔。AIエージェント間の連携、プロンプトの動的生成、Gitコマンドの実行、tmuxセッションの管理、状態監視など、全ての自動化プロセスを司る。
    *   **技術:** Python, `libtmux`, `watchdog`, `subprocess` (Git実行用)。

*   **プロジェクト管理 (Git Repository):**
    *   **役割:** 単一の情報源 (Single Source of Truth)。全てのコード、ドキュメント、タスク定義、変更履歴をGitリポジトリとして管理する。
    *   **技術:** Git。

*   **作業環境 (Git Worktree):**
    *   **役割:** 各AIワーカーに提供される、隔離された一時的な作業ディレクトリ。タスクごとにブランチとワークツリーが動的に作成・破棄される。
    *   **技術:** `git worktree`。

*   **実行環境 (tmux Session):**
    *   **役割:** AIワーカーたちが実際に活動する場。ユーザーは、AIたちが並列で作業する様子をリアルタイムに監視できる。
    *   **技術:** tmux。

#### 3. AIエージェント（AIチームの構成員）

| 役割 | エージェント名 | ハンドルネーム | 責務 |
| :--- | :--- | :--- | :--- |
| **要求分析官** | 対話AI | `[分析官]DialogueAI` | ユーザーとの対話を通じて要求をヒアリングし、**`要件定義書`**を生成する。 |
| **管理者** | 統括AI | `[棟梁]MasterAI` | 要件を技術的な**`タスクリスト(JSON)`**に分解。レビュー結果を基に**マージを最終承認**する。 |
| **開発者** | 開発ワーカー | `[職人]DevAI-xx` | 機能開発タスクを実行し、成果をフィーチャーブランチに**コミット**する。 |
| **品質保証** | QAワーカー | `[監査役]QA-AI-xx` | コードを**レビュー**し、**テストを生成・実行**して品質を保証する。 |

#### 4. プロジェクトのライフサイクルと詳細フロー

**フェーズ 0: プロジェクトの始動 (対話と計画)**

1.  **ユーザー対話:**
    *   ユーザーが`parallelexec agent new --project my-app`を実行。
    *   `[分析官]DialogueAI`が起動し、対話を通じて`my-app/01_requirements.md`を生成。

2.  **リポジトリ初期化:**
    *   `Orchestrator`が`my-app/`ディレクトリで`git init`を実行。

3.  **タスク計画:**
    *   `Orchestrator`が`[棟梁]MasterAI`を起動。プロンプトとして`01_requirements.md`の内容を与える。
    *   `[棟梁]MasterAI`は、開発・レビュー・テストを含むタスクの依存関係グラフを`my-app/02_tasks.json`として出力する。各タスクには`task_type`, `branch_name`, `depends_on`などが定義される。

**フェーズ 1: タスクの並列実行 (開発・QAサイクル)**

*以下のサイクルが、全ての開発タスクに対して並列かつ連続的に実行される*

1.  **開発タスクの開始:**
    *   `Orchestrator`は、依存関係のない`develop`タスク（例: T01）を特定。
    *   `git worktree add worktrees/T01 feature/T01`を実行し、専用の作業環境を用意。
    *   空いている`[職人]DevAI`のtmuxペインに、`T01`のプロンプトを`send-keys`で送信。

2.  **開発とコミット:**
    *   `[職人]DevAI`は指示に従いコードを生成。
    *   完了後、自身のワークツリー内で`git add .`と`git commit -m "feat(T01): ..."`を実行するよう指示される。

3.  **レビュータスクの開始:**
    *   `Orchestrator`は`feature/T01`ブランチへのコミットを検知し、依存する`review`タスク（例: T02）を特定。
    *   空いている`[監査役]QA-AI`のペインを起動。
    *   プロンプトには`git diff main..feature/T01`の結果を含め、レビューを指示。

4.  **レビューの実行:**
    *   `[監査役]QA-AI`はコード差分を分析し、「承認」または「修正要求」を結果として出力する。（「修正要求」の場合は、新しい`develop`タスクが生成されるフローに進む）

5.  **テストタスクの開始:**
    *   レビュー「承認」後、`Orchestrator`は依存する`test`タスク（例: T03）を特定。
    *   `git worktree add worktrees/T03 test/T03 feature/T01`を実行し、**開発ブランチからテスト用の環境を派生させる。**
    *   別の`[監査役]QA-AI`に、テストコードの生成、実行、そして結果のコミットを指示。

**フェーズ 2: 統合とクリーンアップ (マージ)**

1.  **最終承認:**
    *   テスト成功後、`Orchestrator`は`[棟梁]MasterAI`を起動。
    *   プロンプトには、開発ブランチの差分、レビュー結果、テスト結果の要約が含められ、最終的なマージの可否を問う。

2.  **マージ実行:**
    *   `[棟梁]MasterAI`が「承認」した場合、`Orchestrator`は`main`ブランチに以下を順次マージする。
        1.  `feature/T01` (機能)
        2.  `test/T03` (テストコード)
    *   マージにはFast-forwardを避けるため`--no-ff`オプションを使用し、マージコミットを明確に残す。

3.  **環境の破棄:**
    *   `Orchestrator`は`git worktree remove`と`git branch -d`を使い、完了したタスクに関連する全てのワークツリーとブランチを完全に削除し、リポジトリをクリーンな状態に保つ。

**フェーズ 3: プロジェクトの完了**

*   全てのタスクが完了し、`main`ブランチに統合されると、`Orchestrator`はプロジェクト完了を宣言し、最終的な成果物が`my-app/`のルートにあることをユーザーに通知する。

#### 5. まとめ: この設計の優位性

*   **自律性:** 一度要件が定義されれば、人間の介入なしに開発からテスト、マージまでが自動で進行する。
*   **分離と並列性:** `git worktree`により、AIワーカーは互いに干渉することなく、複数のタスクを同時に安全に進めることができる。
*   **品質保証:** 開発と検証の役割を分離し、レビューとテストの工程を必須とすることで、生成されるコードの品質と信頼性を担保する。
*   **透明性と追跡性:** 全ての作業履歴はGitのコミットログとして、全ての意思決定プロセスはJSONやMarkdownファイルとして記録され、完全な追跡が可能。
*   **堅牢性:** タスク失敗時の影響範囲がブランチ内に限定され、メインブランチは常に安定しているため、エラーからの回復が容易。

